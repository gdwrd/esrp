package crypto

import (
	"bytes"
	"crypto"
	"crypto/hmac"
	"crypto/rand"
	"log"

	"github.com/nsheremet/esrp/value"
	v "github.com/nsheremet/esrp/value"
	"golang.org/x/crypto/pbkdf2"
)

// Standard struct: Golang Stdlib crypto engine
//
// Provides:
// - hash: SHA1, SHA256, SHA348, SHA512
// - mac: hmac with selected hash
//
// Defaults to SHA256_HMAC
type Standard struct {
	hasher    crypto.Hash
	kdfIter   int
	legacyKdf bool
	legacyMac bool
}

// NewStandard public function:
//
// Params:
// - hash {crypto.Hash} Hash type, example: SHA1, SHA256, SHA512
//
// Response:
// - {Standard}
func NewStandard(hash crypto.Hash) Standard {
	return Standard{
		hasher:  hash,
		kdfIter: 20000,
	}
}

// NewStandardWithParams public function:
//
// Params:
// - hash {crypto.Hash} Hash type
// - kdf {bool} - if true, using Legacy Kdf
// - mac {bool} - if true, using Legacy Mac
//
// Response:
// - {Standard}
func NewStandardWithParams(hash crypto.Hash, kdf, mac bool) Standard {
	return Standard{
		hasher:    hash,
		kdfIter:   20000,
		legacyKdf: kdf,
		legacyMac: mac,
	}
}

// H public function:
//
// Params:
// - values {[]esrp.Value} values to be hashed
//
// Response:
// - esrp.Value one-way hash function result
func (s Standard) H(values ...v.Value) v.Value {
	hash := s.hasher.New()
	l := len(values[0].Bytes())

	for _, value := range values {
		_, err := hash.Write(pad(value.Bytes(), l))

		if err != nil {
			log.Fatal(err)
		}
	}

	return v.New(hash.Sum(nil))
}

// PasswordHash public function: password-based key derivation function
//
// Params:
// - salt {esrp.Value} random generated salt
// - password {string} plain-text password
//
// Response:
// - esrp.Value
func (s Standard) PasswordHash(salt v.Value, password string) v.Value {
	if s.legacyKdf {
		hash := s.hasher.New()
		hash.Write([]byte(salt.Hex())) // FIXME: maybe here should be: salt.Bytes()
		hash.Write([]byte(password))

		return v.New(hash.Sum(nil))
	}

	return v.New(pbkdf2.Key(
		[]byte(password),
		salt.Bytes(),
		s.kdfIter,
		s.hasher.Size(),
		s.hasher.New,
	))
}

// KeyedHash public function: keyed hash transform function
//
// Params:
// - key {esrp.Value}
// - msg {esrp.Value}
//
// Response:
// - esrp.Value
func (s Standard) KeyedHash(key, msg v.Value) v.Value {
	if s.legacyMac {
		hash := s.hasher.New()
		hash.Write(msg.Bytes())
		hash.Write(key.Bytes())

		return v.New(hash.Sum(nil))
	}

	hash := hmac.New(s.hasher.New, key.Bytes())
	hash.Write(msg.Bytes())
	return v.New(hash.Sum(nil))
}

// Random function: random string generator
//
// Params:
// - bytesLength {int} length of desired generated bytes
//
// Response:
// - {esrp.Value}
func (s Standard) Random(bytesLength int) v.Value {
	string := make([]byte, bytesLength)
	rand.Read(string)

	return value.New(string)
}

// SecureCompare function constant-time string comparison
//
// Compare two strings avoiding timing attacks
//
// Params:
// - a {esrp.Value}
// - b {esrp.Value}
//
// Response:
// - {bool} true if strings are equal
func (s Standard) SecureCompare(a v.Value, b v.Value) bool {
	return bytes.Equal(a.Bytes(), b.Bytes())
}

// pad function: implements byte padding
//
// Params:
// - value  {[]byte}
// - length {int}
//
// Response:
// - {[]byte}
func pad(value []byte, length int) []byte {
	if len(value) >= length {
		return value
	}

	size := 1

	for ((len(value) + size) % length) != 0 {
		size = size + 1
	}

	pad := bytes.Repeat([]byte{byte(0)}, size)
	return append(pad, value...)
}
